; https://hlorenzi.github.io/customasm/web/

#bankdef prg      { #addr 0x0000, #size 0x3ffe, #outp 8 * 0x0   }
#bankdef zeropage { #addr 0x8000, #size 0x100 }
#bankdef ram      { #addr 0x8000, #size 0x7ffe }



#ruledef
{
	lda #{value: i8}	 => 0x00 @ value
	lda {value: i16}	 => 0x01 @ value[7:0]
	lda {value :i8}		 => 0x01 @ value
	nop					 => 0x02 @ 0x00
	lda (x)				 => 0x05 @ 0x00
	lda (y,#{value : i8}) => 0x09 @ value
	lda y		         => 0x0b @ 0x00
	lda (y,x)			 => 0x0d @ 0x00

	ldx #{value: i8}	 => 0x10 @ value
	ldx {value: i16}	 => 0x11 @ value[7:0]
	ldx {value :i8}	 	 => 0x11 @ value
	ldx ac				 => 0x12 @ 0x00

	ldy #{value: i8}	 => 0x14 @ value
	ldy {value: i16}	 => 0x15 @ value[7:0]
	ldy {value :i8}	 	 => 0x15 @ value
	ldy ac				 => 0x16 @ 0x00

	ldv #{value: i8}	 => 0x18 @ value
	ldv {value: i16}	 => 0x19 @ value[7:0]
	ldv {value :i8}	 	 => 0x19 @ value
	ldv ac				 => 0x1A @ 0x00
	ldv (y,x)		 	 => 0x1D @ 0x00
	ldv y				 => 0x1F @ 0x00

	anda #{value: i8}	 => 0x20 @ value
	anda {value: i16}	 => 0x21 @ value[7:0]
	anda {value :i8}	 => 0x21 @ value
	anda (x)			 => 0x25 @ 0x00
	anda (y,#{value :i8}) => 0x29 @ value
	anda y		         => 0x2b @ 0x00
	anda (y,x)			 => 0x2d @ 0x00

	andx #{value: i8}	 => 0x30 @ value
	andx {value: i16}	 => 0x31 @ value[7:0]
	andx {value :i8}	 => 0x31 @ value

	andy #{value: i8}	 => 0x34 @ value
	andy {value: i16}	 => 0x35 @ value[7:0]
	andy {value :i8}	 => 0x35 @ value
	andy ac				 => 0x36 @ 0x00 ; move ac to y

	andv #{value: i8}	 => 0x38 @ value
	andv {value: i16}	 => 0x39 @ value[7:0]
	andv {value :i8}	 => 0x39 @ value
	andv (y,x)		 	 => 0x3D @ 0x00
	andv y				 => 0x3F @ 0x00

	ora #{value: i8}	 => 0x40 @ value
	ora {value: i16}	 => 0x41 @ value[7:0]
	ora {value :i8}	 	 => 0x41 @ value
	ora (x)			 	 => 0x45 @ 0x00
	ora (y,#{value :i8}) => 0x49 @ value
	ora y		         => 0x4b @ 0x00
	ora (y,x)			 => 0x4d @ 0x00

	orx #{value: i8}	 => 0x50 @ value
	orx {value: i16}	 => 0x51 @ value[7:0]
	orx {value :i8}	 	 => 0x51 @ value

	ory #{value: i8}	 => 0x54 @ value
	ory {value: i16}	 => 0x55 @ value[7:0]
	ory {value :i8}	 	 => 0x55 @ value
	ory ac				 => 0x56 @ 0x00 ; move ac to y

	orv #{value: i8}	 => 0x58 @ value
	orv {value: i16}	 => 0x59 @ value[7:0]
	orv {value :i8}	 	 => 0x59 @ value
	orv (y,x)		 	 => 0x5D @ 0x00
	orv y				 => 0x5F @ 0x00
	
	xora #{value: i8}	 => 0x60 @ value
	xora {value: i16}	 => 0x61 @ value[7:0]
	xora {value :i8}	 => 0x61 @ value
	xora ac				 => 0x62 @ 0x00 ; clr ac
	clra				 => 0x62 @ 0x00
	xora (x)			 => 0x65 @ 0x00
	xora (y,#{value :i8}) => 0x69 @ value
	xora y		         => 0x6b @ 0x00
	xora (y,x)			 => 0x6d @ 0x00

	xorx #{value: i8}	 => 0x70 @ value
	xorx {value: i16}	 => 0x71 @ value[7:0]
	xorx {value :i8}	 => 0x71 @ value
	clrx 				 => 0x72 @ value ; xor ac with ac and store in X
	
	xory #{value: i8}	 => 0x74 @ value
	xory {value: i16}	 => 0x75 @ value[7:0]
	xory {value :i8}	 => 0x75 @ value
	xory ac				 => 0x76 @ 0x00 ; clr y
	clry				 => 0x76 @ 0x00

	xorv #{value: i8}	 => 0x78 @ value
	xorv {value: i16}	 => 0x79 @ value[7:0]
	xorv {value :i8}	 => 0x79 @ value
	xorv (y,x)		 	 => 0x7D @ 0x00
	xorv y				 => 0x7F @ 0x00

	adda #{value: i8}	 => 0x80 @ value
	adda {value: i16}	 => 0x81 @ value[7:0]
	adda {value :i8}	 => 0x81 @ value
	adda ac				 => 0x82 @ 0x00 ; shl ac
	shl 			     => 0x82 & 0x00
	adda (x)			 => 0x85 @ 0x00
	adda (y,#{value :i8}) => 0x89 @ value
	adda y		         => 0x8b @ 0x00
	adda (y,x)			 => 0x8d @ 0x00

	addx #{value: i8}	 => 0x90 @ value
	addx {value: i16}	 => 0x91 @ value[7:0]
	addx {value :i8}	 => 0x91 @ value

	addy #{value: i8}	 => 0x94 @ value
	addy {value: i16}	 => 0x95 @ value[7:0]
	addy {value :i8}	 => 0x95 @ value
	addy ac				 => 0x96 @ 0x00 ; shl ac and store in y

	addv #{value: i8}	 => 0x98 @ value
	addv {value: i16}	 => 0x99 @ value[7:0]
	addv {value :i8}	 => 0x99 @ value
	addv (y,x)		 	 => 0x9D @ 0x00
	addv y				 => 0x9F @ 0x00

	suba #{value: i8}	 => 0xa0 @ value
	suba {value: i16}	 => 0xa1 @ value[7:0]
	suba {value :i8}	 => 0xa1 @ value
	suba (x)			 => 0xa5 @ 0x00
	suba (y,#{value :i8}) => 0xa9 @ value
	suba y		         => 0xab @ 0x00
	suba (y,x)			 => 0xad @ 0x00

	subx #{value: i8}	 => 0xb0 @ value
	subx {value: i16}	 => 0xb1 @ value[7:0]
	subx {value :i8}	 => 0xb1 @ value

	suby #{value: i8}	 => 0xb4 @ value
	suby {value: i16}	 => 0xb5 @ value[7:0]
	suby {value :i8}	 => 0xb5 @ value
	suby ac				 => 0xb6 @ 0x00

	subv #{value: i8}	 => 0xb8 @ value
	subv {value: i16}	 => 0xb9 @ value[7:0]
	subv {value :i8}	 => 0xb9 @ value
	subv (y,x)		 	 => 0xbD @ 0x00
	subv y				 => 0xbF @ 0x00
	
	sti #{value: i8},({value2: i8})	 => 0xc0 @ value
	sta {value: i8}		 => 0xc2 @ value
	sta {value: i16}	 => 0xc2 @ value[7:0]
;	sty {value: i8}		 => 0xc3 @ value
;	sty {value: i16}	 => 0xc3 @ value[7:0]

	sti #{value: i8},(x) => 0xc4 @ value
	sta (x)	 			 => 0xc6 @ 0x00
;	sty (x)	 			 => 0xc7 @ 0x00

	sti #{value: i8},(y,{value2: i8}) => 0xc8 @ value
	sta (y,#{value: i8}) => 0xca @ value
	sty (y,#{value: i8}) => 0xcb @ value

	sti #{value: i8},(y,x) 			 => 0xcc @ value
	sta (y,x) 			 => 0xce @ 0x00
	sty (y,x) 			 => 0xcf @ 0x00

	sti #{value: i8},({value2: i8}),x => 0xd0 @ value
	sta {value: i8},x => 0xd2 @ value
;	sty {value: i8},x => 0xd3 @ value

	sti #{value: i8},({value2: i8}),y => 0xd4 @ value
	sta {value: i8},y => 0xd6 @ value
;	sty {value: i8},y => 0xd7 @ value

	jmp	{value: i8}	     => 0xe0 @ value
	jmp ({value: i8})	 => 0xe1 @ value
	jmp ({value: i16})	 => 0xe1 @ value[7:0]
	jmp ac				 => 0xe200
	reti				 => 0xe300
	
	bgt {value: i8}	 	 => 0xe4 @ value
	bgt ({value: i8})	 => 0xe5 @ value
	bgt ({value: i16})	 => 0xe5 @ value[7:0]
	bgt ac				 => 0xe600
	bgt y				 => 0xe700

	blt {value: i8}		 => 0xe8 @ value
	blt ({value: i8})	 => 0xe9 @ value
	blt ({value: i16})	 => 0xe9 @ value[7:0]
	blt ac				 => 0xea00
	blt y				 => 0xeb00

	bne {value: i8}		 => 0xec @ value
	bne ({value: i8})	 => 0xed @ value
	bne ({value: i16})	 => 0xed @ value[7:0]
	bne ac				 => 0xee00
	bne y				 => 0xef00

	beq {value: i8}	 	 => 0xf0 @ value
	beq ({value: i8})	 => 0xf1 @ value
	beq ({value: i16})	 => 0xf1 @ value[7:0]
	beq ac				 => 0xf200
	beq y				 => 0xf300

	bge {value: i8}		 => 0xf4 @ value
	bge ({value: i8})	 => 0xf5 @ value
	bge ({value: i16})	 => 0xf5 @ value[7:0]
	bge ac				 => 0xf600
	bge y				 => 0xf700

	ble {value: i8}		 => 0xf8 @ value
	ble ({value: i8})	 => 0xf9 @ value
	ble ({value: i16})	 => 0xf9 @ value[7:0]
	ble ac				 => 0xfa00
	ble y				 => 0xfb00

	bra {value: i8}		 => 0xfc @ value
	bra ({value: i8})	 => 0xfd @ value
	bra ({value: i16})	 => 0xfd @ value[7:0]
	bra ac				 => 0xfe00
	bra y				 => 0xff00

}

VIDBLACK = 0x40
VIDSYNC = 0x00
AUDIOPAGE = 0x40

#bank zeropage

acStore: #res 1
yStore: #res 1
xStore: #res 1
bootCheck: #res 1
testCount: #res 1
yLineNumber : #res 1
lineMode : #res 1		; stores address for active line/higheq/loweq
subLineMode : #res 1	; stores how many times mode has been called
highEqCnt : #res 1		; number of high equalization pulses in this frame
lowEqCnt : #res 1		; number of low equalization pulses in this frame

#bank prg

interrupt:
	; store registers and reload timer
	sta acStore   ; #1
	sty yStore    ; #2
	
	; check for cold boot
	lda bootCheck ; #3
	xora #55      ; #4
	bne boot      ; #5

    ; branch to one of three routines
	; draw active lines (120 times per frame)
	; high equalization half-line (6 times)
	; low equalization half-line (6 times)
	; high equalization half-line (6 times)
	; blank lines (11 times)
    bra (lineMode) ; #6

	;active line
	;frontporch 10 clocks
	;sync low 15 clocks
	;sync high 15 clocks
	;active pixels 160 clocks
	
	; 12 high equalization lines, then 12 low equalization lines, 
	;  then 12 high again, then 10 blank video lines

    ; Load line address
activeVideo:
    ldy yLineNumber ; #7
    ldv (y,x)     ; #40  draw active video pixel
	;; repeat 159 times    
	ldv #VIDBLACK ; #1
	
	; increment line number
	lda yLineNumber ; #2
	adda #1			; #3
	sta yLineNumber	; #4

	; check if end of active lines
	lda #120		; #5
	xora y			; #6
	beq highEqualization  ; #7 end of frame

	nop ; #8
    nop ; #9
    ldv #VIDSYNC		  ; #10 - sync start (15 clocks)
	nop ;#13
	nop ;#14
	nop ;#15
	nop ;#16
	nop ;#17
	nop ;#18
	; otherwise branch to active subline 
	ldx #-11          ; #19 restart timer (tweak count)
	bra (subLineMode) ; #20

firstLineStart:
	lda #secondLineStart  ; #21
	sta subLineMode		  ; #22
	lda acStore   ; #23
	ldy yStore    ; #24
	ldv #VIDBLACK ; #25 - sync ends
	reti          ; #26
	
secondLineStart:
	lda #thirdLineStart  ; #21
	sta subLineMode		 ; #22
	lda acStore   ; #23
	ldy yStore    ; #24
	ldv #VIDBLACK ; #25 - sync ends
	reti          ; #26
	
thirdLineStart:
	lda #fourthLineStart  ; #21
	sta subLineMode		  ; #22
	lda acStore   ; #23
	ldy yStore    ; #24
	ldv #VIDBLACK ; #25 - sync ends
	reti          ; #26

fourthLineStart:
	lda #firstLineStart  ; #21
	sta subLineMode		 ; #22
	lda acStore   ; #23
	ldy yStore    ; #24
	ldv #VIDBLACK ; #25 - sync ends
	reti          ; #26

;frontporch 5 clocks
;sync low 7 clocks
;sync high then return
highEqualization:
	bra (subLineMode) ; test active video only - remove later
	
	ldx #70		  ; #9 - restart timer with half a frame	
    ldv #VIDSYNC  ; #10 - sync start (7 clocks)
	lda highEqCnt ; #11
	adda #1	      ; #12
	sta highEqCnt ; #13
	nop ; #14
	nop ; #15
	xora #12	  ; #16
	ldv #VIDBLACK ; #17

	; going to next highEq, or to first lowEq, or to first blank line

	beq .nextBlankLine ; #14

	lda highEqCnt ; 
	xora #6
	beq .nextLowEq

	lda highEqCnt
	xora #22
	beq .firstHighEq ; if branch is taken, A will already be 0
	lda highEqCnt
	.firstHighEq:  
	adda #1
	sta highEqCnt ; #16
	lda #highEqualization ;#18
	sta subLineMode ;#19

	.nextBlankLine:
	
	.nextLowEq:

lowEqualization:

blankLine:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                     boot
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
boot:
	; record that we have booted
	lda #55
    sta bootCheck
	lda #activeVideo
	sta lineMode
	clra
	sta yLineNumber
	sta highEqCnt
	sta lowEqCnt
	
main:
	lda #0
	ldy #AUDIOPAGE
	.loop:
		sta testCount ; test memory by saving and restoring variable
		lda testCount
		adda #1
		sta (y,#0)
		bra .loop
		