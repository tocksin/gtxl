; https://hlorenzi.github.io/customasm/web/

#bankdef prg      { #addr 0x0000, #size 0x3ffe, #outp 8 * 0x0   }
#bankdef zeropage { #addr 0x8000, #size 0x100 }
#bankdef ram      { #addr 0x8000, #size 0x7ffe }



#ruledef
{
	lda #{value: i8}	 => 0x00 @ value
	lda {value: i16}	 => 0x01 @ value[7:0]
	lda {value :i8}		 => 0x01 @ value
	nop					 => 0x02 @ 0x00
	lda y		         => 0x03 @ 0x00
	lda (x)				 => 0x05 @ 0x00
	lda (y,#{value : i8}) => 0x09 @ value
	lda (y,x)			 => 0x0d @ 0x00

	ldx #{value: i8}	 => 0x10 @ value
	ldx {value: i16}	 => 0x11 @ value[7:0]
	ldx {value :i8}	 	 => 0x11 @ value
	ldx ac				 => 0x12 @ 0x00
	ldx y				 => 0x13 @ 0x00

	ldy #{value: i8}	 => 0x14 @ value
	ldy {value: i16}	 => 0x15 @ value[7:0]
	ldy {value :i8}	 	 => 0x15 @ value
	ldy ac				 => 0x16 @ 0x00

	ldv #{value: i8}	 => 0x18 @ value
	ldv {value: i16}	 => 0x19 @ value[7:0]
	ldv {value :i8}	 	 => 0x19 @ value
	ldv ac				 => 0x1A @ 0x00
	ldv y				 => 0x1B @ 0x00
	ldv (y,x)		 	 => 0x1D @ 0x00

	anda #{value: i8}	 => 0x20 @ value
	anda {value: i16}	 => 0x21 @ value[7:0]
	anda {value :i8}	 => 0x21 @ value
	anda y		         => 0x23 @ 0x00
	anda (x)			 => 0x25 @ 0x00
	anda (y,#{value :i8}) => 0x29 @ value
	anda (y,x)			 => 0x2d @ 0x00

	andx #{value: i8}	 => 0x30 @ value
	andx {value: i16}	 => 0x31 @ value[7:0]
	andx {value :i8}	 => 0x31 @ value
	andx y		         => 0x33 @ 0x00 ; and ac with y, store into x

	andy #{value: i8}	 => 0x34 @ value
	andy {value: i16}	 => 0x35 @ value[7:0]
	andy {value :i8}	 => 0x35 @ value
	andy ac				 => 0x36 @ 0x00 ; move ac to y
	andy y				 => 0x37 @ 0x00 ; and ac with y, store into y

	andv #{value: i8}	 => 0x38 @ value
	andv {value: i16}	 => 0x39 @ value[7:0]
	andv {value :i8}	 => 0x39 @ value
	andv (y,x)		 	 => 0x3D @ 0x00

	ora #{value: i8}	 => 0x40 @ value
	ora {value: i16}	 => 0x41 @ value[7:0]
	ora {value :i8}	 	 => 0x41 @ value
	ora y		         => 0x43 @ 0x00
	ora (x)			 	 => 0x45 @ 0x00
	ora (y,#{value :i8}) => 0x49 @ value
	ora (y,x)			 => 0x4d @ 0x00

	orx #{value: i8}	 => 0x50 @ value
	orx {value: i16}	 => 0x51 @ value[7:0]
	orx {value :i8}	 	 => 0x51 @ value
	orx y		         => 0x53 @ 0x00 ; or ac with y, store into x

	ory #{value: i8}	 => 0x54 @ value
	ory {value: i16}	 => 0x55 @ value[7:0]
	ory {value :i8}	 	 => 0x55 @ value
	ory ac				 => 0x56 @ 0x00 ; move ac to y
	ory y				 => 0x57 @ 0x00 ; or ac with y, store into y

	orv #{value: i8}	 => 0x58 @ value
	orv {value: i16}	 => 0x59 @ value[7:0]
	orv {value :i8}	 	 => 0x59 @ value
	orv (y,x)		 	 => 0x5D @ 0x00

	xora #{value: i8}	 => 0x60 @ value
	xora {value: i16}	 => 0x61 @ value[7:0]
	xora {value :i8}	 => 0x61 @ value
	xora ac				 => 0x62 @ 0x00 ; clr ac
	clra				 => 0x62 @ 0x00
	xora y		         => 0x63 @ 0x00
	xora (x)			 => 0x65 @ 0x00
	xora (y,#{value :i8}) => 0x69 @ value
	xora (y,x)			 => 0x6d @ 0x00

	xorx #{value: i8}	 => 0x70 @ value
	xorx {value: i16}	 => 0x71 @ value[7:0]
	xorx {value :i8}	 => 0x71 @ value
	xorx y		         => 0x73 @ 0x00 ; xor ac with y, store into x

	xory #{value: i8}	 => 0x74 @ value
	xory {value: i16}	 => 0x75 @ value[7:0]
	xory {value :i8}	 => 0x75 @ value
	xory ac				 => 0x76 @ 0x00 ; clr y
	clry				 => 0x76 @ 0x00
	xory y				 => 0x77 @ 0x00 ; xor ac with y, store into y

	xorv #{value: i8}	 => 0x78 @ value
	xorv {value: i16}	 => 0x79 @ value[7:0]
	xorv {value :i8}	 => 0x79 @ value
	xorv (y,x)		 	 => 0x7D @ 0x00

	adda #{value: i8}	 => 0x80 @ value
	adda {value: i16}	 => 0x81 @ value[7:0]
	adda {value :i8}	 => 0x81 @ value
	adda ac				 => 0x82 @ 0x00 ; shl ac
	shl 			     => 0x82 & 0x00
	adda y		         => 0x83 @ 0x00
	adda (x)			 => 0x85 @ 0x00
	adda (y,#{value :i8}) => 0x89 @ value
	adda (y,x)			 => 0x8d @ 0x00

	addx #{value: i8}	 => 0x90 @ value
	addx {value: i16}	 => 0x91 @ value[7:0]
	addx {value :i8}	 => 0x91 @ value
	addx y		         => 0x93 @ 0x00 ; add ac with y, store into x

	addy #{value: i8}	 => 0x94 @ value
	addy {value: i16}	 => 0x95 @ value[7:0]
	addy {value :i8}	 => 0x95 @ value
	addy ac				 => 0x96 @ 0x00 ; shl ac and store in y
	addy y				 => 0x97 @ 0x00 ; add ac with y, store into y

	addv #{value: i8}	 => 0x98 @ value
	addv {value: i16}	 => 0x99 @ value[7:0]
	addv {value :i8}	 => 0x99 @ value
	addv (y,x)		 	 => 0x9D @ 0x00

	suba #{value: i8}	 => 0xa0 @ value
	suba {value: i16}	 => 0xa1 @ value[7:0]
	suba {value :i8}	 => 0xa1 @ value
	suba y		         => 0xa3 @ 0x00
	suba (x)			 => 0xa5 @ 0x00
	suba (y,#{value :i8}) => 0xa9 @ value
	suba (y,x)			 => 0xad @ 0x00

	subx #{value: i8}	 => 0xb0 @ value
	subx {value: i16}	 => 0xb1 @ value[7:0]
	subx {value :i8}	 => 0xb1 @ value
	subx y		         => 0xb3 @ 0x00 ; subtract ac with y, store into x

	suby #{value: i8}	 => 0xb4 @ value
	suby {value: i16}	 => 0xb5 @ value[7:0]
	suby {value :i8}	 => 0xb5 @ value
	suby ac				 => 0xb6 @ 0x00
	suby y				 => 0xb7 @ 0x00 ; subtract ac with y, store into y

	subv #{value: i8}	 => 0xb8 @ value
	subv {value: i16}	 => 0xb9 @ value[7:0]
	subv {value :i8}	 => 0xb9 @ value
	subv (y,x)		 	 => 0xbD @ 0x00

	sti #{value: i8},({value2: i8})	 => 0xc0 @ value
	sta {value: i8}		 => 0xc2 @ value
	sta {value: i16}	 => 0xc2 @ value[7:0]
	sty {value: i8}		 => 0xc3 @ value
	sty {value: i16}	 => 0xc3 @ value[7:0]

	sti #{value: i8},(x) => 0xc4 @ value
	sta (x)	 			 => 0xc6 @ 0x00
	sty (x)	 			 => 0xc7 @ 0x00

	sti #{value: i8},(y,{value2: i8}) => 0xc8 @ value
	sta (y,{value: i8}) => 0xca @ value
	sty (y,{value: i8}) => 0xcb @ value

	sti #{value: i8},(y,x) 			 => 0xcc @ value
	sta (y,x) 			 => 0xce @ 0x00
	sty (y,x) 			 => 0xcf @ 0x00

	sti #{value: i8},({value2: i8}),x => 0xd0 @ value
	sta {value: i8},x => 0xd2 @ value
	sty {value: i8},x => 0xd3 @ value

	sti #{value: i8},({value2: i8}),y => 0xd4 @ value
	sta {value: i8},y => 0xd6 @ value
	sty {value: i8},y => 0xd7 @ value

	jmp	{value: i8}	     => 0xe0 @ value
	jmp ({value: i8})	 => 0xe1 @ value
	jmp ac				 => 0xe200
	reti				 => 0xe300
	
	bgt {value: i8}	 	 => 0xe4 @ value
	bgt ({value: i8})	 => 0xe5 @ value
	bgt ac				 => 0xe600
	bgt y				 => 0xe700

	blt {value: i8}		 => 0xe8 @ value
	blt ({value: i8})	 => 0xe9 @ value
	blt ac				 => 0xea00
	blt y				 => 0xeb00

	bne {value: i8}		 => 0xec @ value
	bne ({value: i8})	 => 0xed @ value
	bne ac				 => 0xee00
	bne y				 => 0xef00

	beq {value: i8}	 	 => 0xf0 @ value
	beq ({value: i8})	 => 0xf1 @ value
	beq ac				 => 0xf200
	beq y				 => 0xf300

	bge {value: i8}		 => 0xf4 @ value
	bge ({value: i8})	 => 0xf5 @ value
	bge ac				 => 0xf600
	bge y				 => 0xf700

	ble {value: i8}		 => 0xf8 @ value
	ble ({value: i8})	 => 0xf9 @ value
	ble ac				 => 0xfa00
	ble y				 => 0xfb00

	bra {value: i8}		 => 0xfc @ value
	bra ({value: i8})	 => 0xfd @ value
	bra ac				 => 0xfe00
	bra y				 => 0xff00

}

#bank zeropage

acStore: #res 1
yStore: #res 1
xStore: #res 1
bootCheck: #res 1
testCount: #res 1
yLineNumber : #res 1
subLineAddr : #res 1

#bank prg

interrupt:
	; store registers and reload timer
	sta acStore   ; #1
	sty yStore    ; #2
	ldx #56       ; #3
	
	; check for cold boot
	lda bootCheck ; #4
	xora #55      ; #5
	bne .boot     ; #6
	
    ; Load line address
    ldy yLineNumber ; #7
    ldv (y,x)     ; draw active video pixel
    ;; repeat 159 times    
    
    ;        branch to one of four routines - the last will increment Y.  
    bra (subLineAddr) ; #8
    ;            each will bump branch address to next routine.
    ;        turn on and off the horizontal sync at the right time
    ;        check if we can switch to blank lines

	; end of interrupt routine - restore registers
	lda acStore   ; #36
	ldy yStore    ; #37
	reti          ; #38
	
.boot:
	; record that we have booted
	lda #55
    sta bootCheck
	
.main:
	lda #0
	.loop:
		sta testCount ; test memory by saving and restoring variable
		lda testCount
		adda #1
		ldv ac
		bra .loop
		